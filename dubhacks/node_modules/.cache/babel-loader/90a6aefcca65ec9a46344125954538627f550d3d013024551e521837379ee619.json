{"ast":null,"code":"import _objectSpread from\"/Users/rishivora/Documents/Coding/Hackathons/dubhacks-au25/dubhacks/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{apiClient}from'./apiClient';class UserService{/**\n   * Get user profile\n   */async getUserProfile(userId){const response=await apiClient.get(\"/users/\".concat(userId,\"/profile\"));if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to fetch user profile');}return response.data.data;}/**\n   * Update user profile\n   */async updateUserProfile(userId,profileData){const response=await apiClient.put(\"/users/\".concat(userId,\"/profile\"),profileData);if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to update user profile');}return response.data.data;}/**\n   * Get user preferences\n   */async getUserPreferences(userId){const response=await apiClient.get(\"/users/\".concat(userId,\"/preferences\"));if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to fetch user preferences');}return response.data.data;}/**\n   * Update user preferences\n   */async updateUserPreferences(userId,preferences){const response=await apiClient.put(\"/users/\".concat(userId,\"/preferences\"),preferences);if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to update user preferences');}return response.data.data;}/**\n   * Save an event\n   */async saveEvent(userId,eventId){const response=await apiClient.post(\"/users/\".concat(userId,\"/saved-events/\").concat(eventId));if(!response.data.success){throw new Error(response.data.error||'Failed to save event');}}/**\n   * Remove a saved event\n   */async unsaveEvent(userId,eventId){const response=await apiClient.delete(\"/users/\".concat(userId,\"/saved-events/\").concat(eventId));if(!response.data.success){throw new Error(response.data.error||'Failed to remove saved event');}}/**\n   * Get saved events\n   */async getSavedEvents(userId){const response=await apiClient.get(\"/users/\".concat(userId,\"/saved-events\"));if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to fetch saved events');}// Convert date strings to Date objects\nreturn response.data.data.map(event=>_objectSpread(_objectSpread({},event),{},{startDateTime:new Date(event.startDateTime),endDateTime:new Date(event.endDateTime),createdAt:new Date(event.createdAt),updatedAt:new Date(event.updatedAt),source:_objectSpread(_objectSpread({},event.source),{},{crawlDate:event.source.crawlDate?new Date(event.source.crawlDate):undefined})}));}/**\n   * Get personalized recommendations\n   */async getPersonalizedRecommendations(userId){let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:20;const response=await apiClient.get(\"/users/\".concat(userId,\"/recommendations?limit=\").concat(limit));if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to fetch recommendations');}// Convert date strings to Date objects\nreturn response.data.data.map(event=>_objectSpread(_objectSpread({},event),{},{startDateTime:new Date(event.startDateTime),endDateTime:new Date(event.endDateTime),createdAt:new Date(event.createdAt),updatedAt:new Date(event.updatedAt),source:_objectSpread(_objectSpread({},event.source),{},{crawlDate:event.source.crawlDate?new Date(event.source.crawlDate):undefined})}));}/**\n   * Get complete user profile with statistics\n   */async getCompleteUserProfile(userId){const response=await apiClient.get(\"/users/\".concat(userId,\"/complete-profile\"));if(!response.data.success||!response.data.data){throw new Error(response.data.error||'Failed to fetch complete user profile');}return response.data.data;}/**\n   * Update user interests based on activity\n   */async updateUserInterestsFromActivity(userId){const response=await apiClient.post(\"/users/\".concat(userId,\"/update-interests\"));if(!response.data.success){throw new Error(response.data.error||'Failed to update user interests');}}/**\n   * Check if an event is saved by the user\n   */async isEventSaved(userId,eventId){try{const savedEvents=await this.getSavedEvents(userId);return savedEvents.some(event=>event.eventId===eventId);}catch(error){console.error('Error checking if event is saved:',error);return false;}}}export const userService=new UserService();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}