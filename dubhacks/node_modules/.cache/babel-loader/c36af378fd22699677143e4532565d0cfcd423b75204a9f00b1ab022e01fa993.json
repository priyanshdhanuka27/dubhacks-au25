{"ast":null,"code":"import _objectWithoutProperties from \"/Users/rishivora/Documents/Coding/Hackathons/dubhacks-au25/dubhacks/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/Users/rishivora/Documents/Coding/Hackathons/dubhacks-au25/dubhacks/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"fetchStatus\"];\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const mutations = [];\n  const queries = [];\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n    mutationCache.build(client, _objectSpread(_objectSpread({}, options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations), {}, {\n      mutationKey: dehydratedMutation.mutationKey\n    }), dehydratedMutation.state);\n  });\n  queries.forEach(_ref => {\n    let {\n      queryKey,\n      state,\n      queryHash\n    } = _ref;\n    var _options$defaultOptio2;\n    const query = queryCache.get(queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        // omit fetchStatus from dehydrated state\n        // so that query stays in its current fetchStatus\n        const {\n            fetchStatus: _ignored\n          } = state,\n          dehydratedQueryState = _objectWithoutProperties(state, _excluded);\n        query.setState(dehydratedQueryState);\n      }\n      return;\n    } // Restore query\n\n    queryCache.build(client, _objectSpread(_objectSpread({}, options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries), {}, {\n      queryKey,\n      queryHash\n    }), // Reset fetch status to idle to avoid\n    // query being stuck in fetching state upon hydration\n    _objectSpread(_objectSpread({}, state), {}, {\n      fetchStatus: 'idle'\n    }));\n  });\n}\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}