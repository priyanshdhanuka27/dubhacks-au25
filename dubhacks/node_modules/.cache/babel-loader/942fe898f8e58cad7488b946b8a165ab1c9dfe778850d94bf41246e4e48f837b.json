{"ast":null,"code":"import axios from 'axios';\nimport { config } from '../config';\nimport { authService } from './authService';\nclass ApiClient {\n  constructor() {\n    this.client = void 0;\n    this.client = axios.create({\n      baseURL: config.api.baseUrl,\n      timeout: config.api.timeout,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    this.setupInterceptors();\n  }\n  setupInterceptors() {\n    // Request interceptor to add auth token\n    this.client.interceptors.request.use(\n    // Use a loose type here because Axios internal request config types\n    // can differ between versions of axios. Casting to any keeps this\n    // compatible across environments.\n    cfg => {\n      const token = authService.getStoredToken();\n      if (token && cfg.headers) {\n        cfg.headers.Authorization = `Bearer ${token}`;\n      }\n      return cfg;\n    }, error => {\n      return Promise.reject(error);\n    });\n\n    // Response interceptor to handle token refresh\n    this.client.interceptors.response.use(response => {\n      return response;\n    }, async error => {\n      var _error$response;\n      const originalRequest = error.config;\n\n      // If we get a 401 and haven't already tried to refresh\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n        originalRequest._retry = true;\n        try {\n          // Attempt to refresh the token\n          const refreshResult = await authService.refreshToken();\n          if (refreshResult.success && refreshResult.token) {\n            // Update the authorization header and retry the request\n            originalRequest.headers.Authorization = `Bearer ${refreshResult.token.token}`;\n            return this.client(originalRequest);\n          }\n        } catch (refreshError) {\n          // Refresh failed, redirect to login\n          console.error('Token refresh failed:', refreshError);\n          // Clear auth data and redirect to login\n          await authService.logout();\n          window.location.href = '/auth';\n          return Promise.reject(refreshError);\n        }\n      }\n      return Promise.reject(error);\n    });\n  }\n\n  // HTTP methods\n  async get(url, config) {\n    return this.client.get(url, config);\n  }\n  async post(url, data, config) {\n    return this.client.post(url, data, config);\n  }\n  async put(url, data, config) {\n    return this.client.put(url, data, config);\n  }\n  async patch(url, data, config) {\n    return this.client.patch(url, data, config);\n  }\n  async delete(url, config) {\n    return this.client.delete(url, config);\n  }\n\n  // Get the underlying axios instance if needed\n  getInstance() {\n    return this.client;\n  }\n}\nexport const apiClient = new ApiClient();","map":{"version":3,"names":["axios","config","authService","ApiClient","constructor","client","create","baseURL","api","baseUrl","timeout","headers","setupInterceptors","interceptors","request","use","cfg","token","getStoredToken","Authorization","error","Promise","reject","response","_error$response","originalRequest","status","_retry","refreshResult","refreshToken","success","refreshError","console","logout","window","location","href","get","url","post","data","put","patch","delete","getInstance","apiClient"],"sources":["/Users/rishivora/Documents/Coding/Hackathons/dubhacks-au25/dubhacks/src/services/apiClient.ts"],"sourcesContent":["import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { config } from '../config';\nimport { authService } from './authService';\n\nclass ApiClient {\n  private client: AxiosInstance;\n\n  constructor() {\n    this.client = axios.create({\n      baseURL: config.api.baseUrl,\n      timeout: config.api.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor to add auth token\n    this.client.interceptors.request.use(\n      // Use a loose type here because Axios internal request config types\n      // can differ between versions of axios. Casting to any keeps this\n      // compatible across environments.\n      (cfg: any) => {\n        const token = authService.getStoredToken();\n        if (token && cfg.headers) {\n          cfg.headers.Authorization = `Bearer ${token}`;\n        }\n        return cfg;\n      },\n      (error) => {\n        return Promise.reject(error);\n      }\n    );\n\n    // Response interceptor to handle token refresh\n    this.client.interceptors.response.use(\n      (response: AxiosResponse) => {\n        return response;\n      },\n      async (error) => {\n        const originalRequest = error.config;\n\n        // If we get a 401 and haven't already tried to refresh\n        if (error.response?.status === 401 && !originalRequest._retry) {\n          originalRequest._retry = true;\n\n          try {\n            // Attempt to refresh the token\n            const refreshResult = await authService.refreshToken();\n            \n            if (refreshResult.success && refreshResult.token) {\n              // Update the authorization header and retry the request\n              originalRequest.headers.Authorization = `Bearer ${refreshResult.token.token}`;\n              return this.client(originalRequest);\n            }\n          } catch (refreshError) {\n            // Refresh failed, redirect to login\n            console.error('Token refresh failed:', refreshError);\n            // Clear auth data and redirect to login\n            await authService.logout();\n            window.location.href = '/auth';\n            return Promise.reject(refreshError);\n          }\n        }\n\n        return Promise.reject(error);\n      }\n    );\n  }\n\n  // HTTP methods\n  async get<T>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {\n    return this.client.get<T>(url, config);\n  }\n\n  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {\n    return this.client.post<T>(url, data, config);\n  }\n\n  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {\n    return this.client.put<T>(url, data, config);\n  }\n\n  async patch<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {\n    return this.client.patch<T>(url, data, config);\n  }\n\n  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>> {\n    return this.client.delete<T>(url, config);\n  }\n\n  // Get the underlying axios instance if needed\n  getInstance(): AxiosInstance {\n    return this.client;\n  }\n}\n\nexport const apiClient = new ApiClient();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}